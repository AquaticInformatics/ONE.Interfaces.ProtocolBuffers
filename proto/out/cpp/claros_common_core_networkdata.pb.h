// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: claros_common_core_networkdata.proto

#ifndef PROTOBUF_INCLUDED_claros_5fcommon_5fcore_5fnetworkdata_2eproto
#define PROTOBUF_INCLUDED_claros_5fcommon_5fcore_5fnetworkdata_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "claros_common_form_formtemplate.pb.h"
#include "claros_common_form_form.pb.h"
#include "claros_common_core_clarosdatetime.pb.h"
#include "claros_common_core_note.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_claros_5fcommon_5fcore_5fnetworkdata_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_claros_5fcommon_5fcore_5fnetworkdata_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[2]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_claros_5fcommon_5fcore_5fnetworkdata_2eproto();
namespace claros {
namespace common {
namespace core {
class NetworkData;
class NetworkDataDefaultTypeInternal;
extern NetworkDataDefaultTypeInternal _NetworkData_default_instance_;
class NetworkData_Response;
class NetworkData_ResponseDefaultTypeInternal;
extern NetworkData_ResponseDefaultTypeInternal _NetworkData_Response_default_instance_;
}  // namespace core
}  // namespace common
}  // namespace claros
namespace google {
namespace protobuf {
template<> ::claros::common::core::NetworkData* Arena::CreateMaybeMessage<::claros::common::core::NetworkData>(Arena*);
template<> ::claros::common::core::NetworkData_Response* Arena::CreateMaybeMessage<::claros::common::core::NetworkData_Response>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace claros {
namespace common {
namespace core {

// ===================================================================

class NetworkData_Response :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:claros.common.core.NetworkData.Response) */ {
 public:
  NetworkData_Response();
  virtual ~NetworkData_Response();

  NetworkData_Response(const NetworkData_Response& from);

  inline NetworkData_Response& operator=(const NetworkData_Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetworkData_Response(NetworkData_Response&& from) noexcept
    : NetworkData_Response() {
    *this = ::std::move(from);
  }

  inline NetworkData_Response& operator=(NetworkData_Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const NetworkData_Response& default_instance();

  enum ResponseOneOfCase {
    kFormTemplate = 2,
    kForm = 3,
    kDateTime = 4,
    kNote = 5,
    RESPONSE_ONE_OF_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetworkData_Response* internal_default_instance() {
    return reinterpret_cast<const NetworkData_Response*>(
               &_NetworkData_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(NetworkData_Response* other);
  friend void swap(NetworkData_Response& a, NetworkData_Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetworkData_Response* New() const final {
    return CreateMaybeMessage<NetworkData_Response>(nullptr);
  }

  NetworkData_Response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NetworkData_Response>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NetworkData_Response& from);
  void MergeFrom(const NetworkData_Response& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetworkData_Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .claros.common.form.FormTemplate formTemplate = 2;
  bool has_formtemplate() const;
  void clear_formtemplate();
  static const int kFormTemplateFieldNumber = 2;
  const ::claros::common::form::FormTemplate& formtemplate() const;
  ::claros::common::form::FormTemplate* release_formtemplate();
  ::claros::common::form::FormTemplate* mutable_formtemplate();
  void set_allocated_formtemplate(::claros::common::form::FormTemplate* formtemplate);

  // .claros.common.form.Form form = 3;
  bool has_form() const;
  void clear_form();
  static const int kFormFieldNumber = 3;
  const ::claros::common::form::Form& form() const;
  ::claros::common::form::Form* release_form();
  ::claros::common::form::Form* mutable_form();
  void set_allocated_form(::claros::common::form::Form* form);

  // .claros.common.core.ClarosDateTime dateTime = 4;
  bool has_datetime() const;
  void clear_datetime();
  static const int kDateTimeFieldNumber = 4;
  const ::claros::common::core::ClarosDateTime& datetime() const;
  ::claros::common::core::ClarosDateTime* release_datetime();
  ::claros::common::core::ClarosDateTime* mutable_datetime();
  void set_allocated_datetime(::claros::common::core::ClarosDateTime* datetime);

  // .claros.common.core.Note note = 5;
  bool has_note() const;
  void clear_note();
  static const int kNoteFieldNumber = 5;
  const ::claros::common::core::Note& note() const;
  ::claros::common::core::Note* release_note();
  ::claros::common::core::Note* mutable_note();
  void set_allocated_note(::claros::common::core::Note* note);

  void clear_response_one_of();
  ResponseOneOfCase response_one_of_case() const;
  // @@protoc_insertion_point(class_scope:claros.common.core.NetworkData.Response)
 private:
  class HasBitSetters;
  void set_has_formtemplate();
  void set_has_form();
  void set_has_datetime();
  void set_has_note();

  inline bool has_response_one_of() const;
  inline void clear_has_response_one_of();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ResponseOneOfUnion {
    ResponseOneOfUnion() {}
    ::claros::common::form::FormTemplate* formtemplate_;
    ::claros::common::form::Form* form_;
    ::claros::common::core::ClarosDateTime* datetime_;
    ::claros::common::core::Note* note_;
  } response_one_of_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_claros_5fcommon_5fcore_5fnetworkdata_2eproto;
};
// -------------------------------------------------------------------

class NetworkData :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:claros.common.core.NetworkData) */ {
 public:
  NetworkData();
  virtual ~NetworkData();

  NetworkData(const NetworkData& from);

  inline NetworkData& operator=(const NetworkData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetworkData(NetworkData&& from) noexcept
    : NetworkData() {
    *this = ::std::move(from);
  }

  inline NetworkData& operator=(NetworkData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const NetworkData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetworkData* internal_default_instance() {
    return reinterpret_cast<const NetworkData*>(
               &_NetworkData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(NetworkData* other);
  friend void swap(NetworkData& a, NetworkData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetworkData* New() const final {
    return CreateMaybeMessage<NetworkData>(nullptr);
  }

  NetworkData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NetworkData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NetworkData& from);
  void MergeFrom(const NetworkData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetworkData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef NetworkData_Response Response;

  // accessors -------------------------------------------------------

  // repeated .claros.common.core.NetworkData.Response responses = 1;
  int responses_size() const;
  void clear_responses();
  static const int kResponsesFieldNumber = 1;
  ::claros::common::core::NetworkData_Response* mutable_responses(int index);
  ::google::protobuf::RepeatedPtrField< ::claros::common::core::NetworkData_Response >*
      mutable_responses();
  const ::claros::common::core::NetworkData_Response& responses(int index) const;
  ::claros::common::core::NetworkData_Response* add_responses();
  const ::google::protobuf::RepeatedPtrField< ::claros::common::core::NetworkData_Response >&
      responses() const;

  // @@protoc_insertion_point(class_scope:claros.common.core.NetworkData)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::claros::common::core::NetworkData_Response > responses_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_claros_5fcommon_5fcore_5fnetworkdata_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NetworkData_Response

// .claros.common.form.FormTemplate formTemplate = 2;
inline bool NetworkData_Response::has_formtemplate() const {
  return response_one_of_case() == kFormTemplate;
}
inline void NetworkData_Response::set_has_formtemplate() {
  _oneof_case_[0] = kFormTemplate;
}
inline ::claros::common::form::FormTemplate* NetworkData_Response::release_formtemplate() {
  // @@protoc_insertion_point(field_release:claros.common.core.NetworkData.Response.formTemplate)
  if (has_formtemplate()) {
    clear_has_response_one_of();
      ::claros::common::form::FormTemplate* temp = response_one_of_.formtemplate_;
    response_one_of_.formtemplate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::claros::common::form::FormTemplate& NetworkData_Response::formtemplate() const {
  // @@protoc_insertion_point(field_get:claros.common.core.NetworkData.Response.formTemplate)
  return has_formtemplate()
      ? *response_one_of_.formtemplate_
      : *reinterpret_cast< ::claros::common::form::FormTemplate*>(&::claros::common::form::_FormTemplate_default_instance_);
}
inline ::claros::common::form::FormTemplate* NetworkData_Response::mutable_formtemplate() {
  if (!has_formtemplate()) {
    clear_response_one_of();
    set_has_formtemplate();
    response_one_of_.formtemplate_ = CreateMaybeMessage< ::claros::common::form::FormTemplate >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:claros.common.core.NetworkData.Response.formTemplate)
  return response_one_of_.formtemplate_;
}

// .claros.common.form.Form form = 3;
inline bool NetworkData_Response::has_form() const {
  return response_one_of_case() == kForm;
}
inline void NetworkData_Response::set_has_form() {
  _oneof_case_[0] = kForm;
}
inline ::claros::common::form::Form* NetworkData_Response::release_form() {
  // @@protoc_insertion_point(field_release:claros.common.core.NetworkData.Response.form)
  if (has_form()) {
    clear_has_response_one_of();
      ::claros::common::form::Form* temp = response_one_of_.form_;
    response_one_of_.form_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::claros::common::form::Form& NetworkData_Response::form() const {
  // @@protoc_insertion_point(field_get:claros.common.core.NetworkData.Response.form)
  return has_form()
      ? *response_one_of_.form_
      : *reinterpret_cast< ::claros::common::form::Form*>(&::claros::common::form::_Form_default_instance_);
}
inline ::claros::common::form::Form* NetworkData_Response::mutable_form() {
  if (!has_form()) {
    clear_response_one_of();
    set_has_form();
    response_one_of_.form_ = CreateMaybeMessage< ::claros::common::form::Form >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:claros.common.core.NetworkData.Response.form)
  return response_one_of_.form_;
}

// .claros.common.core.ClarosDateTime dateTime = 4;
inline bool NetworkData_Response::has_datetime() const {
  return response_one_of_case() == kDateTime;
}
inline void NetworkData_Response::set_has_datetime() {
  _oneof_case_[0] = kDateTime;
}
inline ::claros::common::core::ClarosDateTime* NetworkData_Response::release_datetime() {
  // @@protoc_insertion_point(field_release:claros.common.core.NetworkData.Response.dateTime)
  if (has_datetime()) {
    clear_has_response_one_of();
      ::claros::common::core::ClarosDateTime* temp = response_one_of_.datetime_;
    response_one_of_.datetime_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::claros::common::core::ClarosDateTime& NetworkData_Response::datetime() const {
  // @@protoc_insertion_point(field_get:claros.common.core.NetworkData.Response.dateTime)
  return has_datetime()
      ? *response_one_of_.datetime_
      : *reinterpret_cast< ::claros::common::core::ClarosDateTime*>(&::claros::common::core::_ClarosDateTime_default_instance_);
}
inline ::claros::common::core::ClarosDateTime* NetworkData_Response::mutable_datetime() {
  if (!has_datetime()) {
    clear_response_one_of();
    set_has_datetime();
    response_one_of_.datetime_ = CreateMaybeMessage< ::claros::common::core::ClarosDateTime >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:claros.common.core.NetworkData.Response.dateTime)
  return response_one_of_.datetime_;
}

// .claros.common.core.Note note = 5;
inline bool NetworkData_Response::has_note() const {
  return response_one_of_case() == kNote;
}
inline void NetworkData_Response::set_has_note() {
  _oneof_case_[0] = kNote;
}
inline ::claros::common::core::Note* NetworkData_Response::release_note() {
  // @@protoc_insertion_point(field_release:claros.common.core.NetworkData.Response.note)
  if (has_note()) {
    clear_has_response_one_of();
      ::claros::common::core::Note* temp = response_one_of_.note_;
    response_one_of_.note_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::claros::common::core::Note& NetworkData_Response::note() const {
  // @@protoc_insertion_point(field_get:claros.common.core.NetworkData.Response.note)
  return has_note()
      ? *response_one_of_.note_
      : *reinterpret_cast< ::claros::common::core::Note*>(&::claros::common::core::_Note_default_instance_);
}
inline ::claros::common::core::Note* NetworkData_Response::mutable_note() {
  if (!has_note()) {
    clear_response_one_of();
    set_has_note();
    response_one_of_.note_ = CreateMaybeMessage< ::claros::common::core::Note >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:claros.common.core.NetworkData.Response.note)
  return response_one_of_.note_;
}

inline bool NetworkData_Response::has_response_one_of() const {
  return response_one_of_case() != RESPONSE_ONE_OF_NOT_SET;
}
inline void NetworkData_Response::clear_has_response_one_of() {
  _oneof_case_[0] = RESPONSE_ONE_OF_NOT_SET;
}
inline NetworkData_Response::ResponseOneOfCase NetworkData_Response::response_one_of_case() const {
  return NetworkData_Response::ResponseOneOfCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// NetworkData

// repeated .claros.common.core.NetworkData.Response responses = 1;
inline int NetworkData::responses_size() const {
  return responses_.size();
}
inline void NetworkData::clear_responses() {
  responses_.Clear();
}
inline ::claros::common::core::NetworkData_Response* NetworkData::mutable_responses(int index) {
  // @@protoc_insertion_point(field_mutable:claros.common.core.NetworkData.responses)
  return responses_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::claros::common::core::NetworkData_Response >*
NetworkData::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_list:claros.common.core.NetworkData.responses)
  return &responses_;
}
inline const ::claros::common::core::NetworkData_Response& NetworkData::responses(int index) const {
  // @@protoc_insertion_point(field_get:claros.common.core.NetworkData.responses)
  return responses_.Get(index);
}
inline ::claros::common::core::NetworkData_Response* NetworkData::add_responses() {
  // @@protoc_insertion_point(field_add:claros.common.core.NetworkData.responses)
  return responses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::claros::common::core::NetworkData_Response >&
NetworkData::responses() const {
  // @@protoc_insertion_point(field_list:claros.common.core.NetworkData.responses)
  return responses_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace core
}  // namespace common
}  // namespace claros

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_claros_5fcommon_5fcore_5fnetworkdata_2eproto
